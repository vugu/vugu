//go:build mage

// This is the magefile used to build and test the 'vugu' project.
// Execute 'mage -l' for a list of the available targets.
// This magefile requires that 'docker' is installed.
// For 'docker' install instructions see:https://docs.docker.com/engine/install/
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"log"

	"github.com/magefile/mage/mg"
	"github.com/magefile/mage/sh"
)

// All builds and tests vugu.
// This includes running both the the 'vugu' tests and the full 'wasm-test-suite' set of test cases.
// These test cases are built with both the standard Go compiler and the TinyGo compiler.
// As a result the "All" target may take 35 minutes to complete.
// If you do not need to run the 'wasm-test-suite' see the "AllFast" target
func All() error {
	mg.SerialDeps(
		CheckRequiredCmdsExist,
		CleanAutoGeneratedFiles,
		Build,
		PullLatestGolangCiLintDockerImage,
		Lint, // we can't run golangci-lint in parallel with the Build as that calls "go generate"
		Test,
		PullLatestTinyGoDockerImage,
		TestWasm,
		WasmTestSuiteRefactor,
	)
	return nil
}

// Like the "All" target but does NOT run the 'wasm-test-suite' test cases.
func AllFast() error {
	mg.SerialDeps(
		CheckRequiredCmdsExist,
		CleanAutoGeneratedFiles,
		Build,
		PullLatestGolangCiLintDockerImage,
		Lint, // we can't run golangci-lint in parallel with the Build as that calls "go generate"
		Test,
		WasmTestSuiteRefactor,
	)
	return nil
}

// Like the "AllFast" target but does NOT run the linter, as the Dockerized 'golangci-lint' can take 40+ seconds to run
func AllFastNoLint() error {
	mg.SerialDeps(
		CheckRequiredCmdsExist,
		CleanAutoGeneratedFiles,
		Build,
		Test,
		WasmTestSuiteRefactor,
	)
	return nil
}

// Checks that all required commands have been installed prior to attempting the build.
// The only required command at present is 'docker'.
func CheckRequiredCmdsExist() error {
	return checkAllCmdsExist("docker") // currently docker is theonly required external commands
}

// Searches for any files whose filename matches "*_gen.go" or "*.wasm" and deletes them.
func CleanAutoGeneratedFiles() error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	return filepath.WalkDir(cwd, deleteGeneratedFiles)

}

// Build the 'vugu' package, the 'vugugen' and 'vugufmt' commands. It also generates the auto-generated files in the 'vgfrom' package.
// These generated files are required by the tests.
func Build() error {
	// install the vugu module by executing
	// go install github.com/vugu/vugu
	err := goCmdV("install", "github.com/vugu/vugu")
	if err != nil {
		return err
	}
	// install the vugugen command by executing
	// - go install github.com/vugu/vugu/cmd/vugugen
	err = goCmdV("install", "github.com/vugu/vugu/cmd/vugugen")
	if err != nil {
		return err
	}
	// install the vugufmt command by executing
	// go install github.com/vugu/vugu/cmd/vugufmt
	err = goCmdV("install", "github.com/vugu/vugu/cmd/vugufmt")
	if err != nil {
		return err
	}
	// run go generate in the vgform package by executing
	// go generate github.com/vugu/vugu/vgform # go generate calls vugugen
	err = goCmdV("generate", "github.com/vugu/vugu/vgform")
	return err
}

// Pulls the latest version of the 'golangci-lint' docker image. 'goalngci-lint' is is used as the 'vugu' projects lint tool. See the Lint target
func PullLatestGolangCiLintDockerImage() error {
	mg.Deps(CheckRequiredCmdsExist)
	return dockerCmdV("pull", "golangci/golangci-lint:latest-alpine")
}

// Lints the 'vugu' source code including the tests and any generated files. The linter is a dockerized version of the 'golangci-lint' linter.
// See: https://golangci-lint.run/
func Lint() error {
	mg.Deps(CheckRequiredCmdsExist)
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	dashVArg := cwd + ":/app"
	return dockerCmdV("run", "--rm", "-v", dashVArg, "-w", "/app", "golangci/golangci-lint:latest-alpine", "golangci-lint", "run", "-v")
}

// Runs all of the tests for 'vugu', except the 'wasm-test-suite' tests using the standard Go compiler.
func Test() error {
	mg.Deps(CheckRequiredCmdsExist)
	output, err := goCmdCaptureOutput("list", "./...")
	if err != nil {
		return err
	}
	packages := strings.Split(output, "\n")
	for _, pkg := range packages {
		if strings.Contains(pkg, "wasm-test-suite") {
			continue // skip the wasm-test-suite packages
		}
		err = goCmdV("test", "-v", pkg)
		if err != nil {
			return err
		}
	}
	return nil
}

// Pulls the latest version of the 'tinygo' Go compiler docker image. 'tinygo' is an alternative Go compiler used by the 'vugu' to generate the Web Assembly (wasm) files.
// 'vugu' uses it only to ensure tha the 'wasm-test-suite' can be built using 'tinygo' compiler.
// 'tinygo' DOES NOT support the full Go standard library, when compiling to wasm. As such you may not be able to compile your project using 'tinygo'. See: https://tinygo.org/docs/reference/lang-support/stdlib/
func PullLatestTinyGoDockerImage() error {
	mg.Deps(CheckRequiredCmdsExist)
	return dockerCmdV("pull", "tinygo/tinygo:latest")
}

// Run the 'wasm-test-suite' building the tests cases using both the standard Go compiler and the 'tinygo' compiler.
// The tests are served via a docker container image that contains a local web server, and used a headless chrome browser to
// fetch and execute the wasm.
// This test suite can take 35 minutes to execute.
func TestWasm() error {
	mg.Deps(CheckRequiredCmdsExist)
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	defer func() {
		_ = os.Chdir(cwd)
	}()
	err = os.Chdir("./wasm-test-suite/docker")
	if err != nil {
		return err
	}
	// build the wasm-test-suite-srv
	envs := map[string]string{
		"CGO_ENABLED": "0",
		"GOOS":        "linux",
		"GOARCH":      "amd64",
	}
	err = goCmdWithV(envs, "build", "-o", "./wasm-test-suite-srv", "github.com/vugu/vugu/wasm-test-suite/docker")
	if err != nil {
		return err
	}
	err = dockerCmdV("build", "-t", "vugu/wasm-test-suite:latest", ".")
	if err != nil {
		return err
	}
	// We intend to ignore any errors here, as the container might not be running
	dockerCmdV("stop", "wasm-test-suite")
	dockerCmdV("rm", "wasm-test-suite")
	err = dockerCmdV("run", "-d", "-t", "-p", "9222:9222", "-p", "8846:8846", "--name", "wasm-test-suite", "vugu/wasm-test-suite:latest")
	if err != nil {
		return err
	}
	// stop the running container on function exit
	defer func() {
		// We intend to ignore any errors here, as the container might not be running
		dockerCmdV("stop", "wasm-test-suite")
	}()
	return goCmdV("test", "-v", "-timeout", "35m", "github.com/vugu/vugu/wasm-test-suite")
}

func PullLatestNginxImage() error {
	mg.Deps(CheckRequiredCmdsExist)
	return dockerCmdV("pull", "nginx:latest")
}

func PullLatestChromeDpImage() error {
	mg.Deps(CheckRequiredCmdsExist)
	return dockerCmdV("pull", "chromedp/headless-shell:latest")
}

func WasmTestSuiteRefactor() error {
	mg.SerialDeps(CheckRequiredCmdsExist, PullLatestNginxImage, PullLatestChromeDpImage)
	_ = cleanupContainer("vugu-nginx")
	_ = cleanupContainer("vugu-chromedp")
	// remove any bridge network that we may have created previously
	cleanupContainerNetwork("vugu-net")
	// create the container network named "vugu-net"
	err := dockerCmdV("network", "create", "--driver", "bridge", "vugu-net")
	if err != nil {
		return err
	}
	defer func() {
		_ = cleanupContainerNetwork("vugu-net")
	}()

	mountArg := "type=bind,source=./new-tests,target=/usr/share/nginx/html,readonly"
	// start the nginx container and attach it to the new vugu-net network
	err = dockerCmdV("run", "--name", "vugu-nginx", "--network", "vugu-net", "--mount", mountArg, "-p", "8888:80", "-d", "nginx")
	if err != nil {
		return err
	}
	defer func() {
		_ = cleanupContainer("vugu-nginx")
	}()
	// add the vugu-ngix container to the defautl bridgenetwork as well (so the container has outbound internet access)
	err = dockerCmdV("network", "connect", "bridge", "vugu-nginx")
	if err != nil {
		return err
	}
	// start the chromedp container
	err = dockerCmdV("run", "-d", "-t", "-p", "9222:9222", "--name", "vugu-chromedp", "--network", "vugu-net", "chromedp/headless-shell")
	if err != nil {
		return err
	}
	defer func() {
		_ = cleanupContainer("vugu-chromedp")
	}()
	// add the vugu-chromdp container to the default bridgenetwork as well (so the container has outbound internet access)
	err = dockerCmdV("network", "connect", "bridge", "vugu-chromedp")
	if err != nil {
		return err
	}

	// check the containers are running
	out, err := sh.Output("docker", "ps")
	if err != nil {
		return err
	}
	log.Println(out)

	// build the wasm binary

	err = runGoGenerateInTestDirs()
	if err != nil {
		return err
	}
	err = runGoModTidyInTestDirs()
	if err != nil {
		return err
	}

	err = runGoBuildInTestDirs()
	if err != nil {
		return err
	}

	return runGoTestInTestDirs()
	// cleanup via the deferred functions
}

func runGoGenerateInTestDirs() error {
	f := func() error {
		// cd into the directory and run go generate followed by go mod tidy
		log.Printf("About to tun: go generate")
		return goCmdV("generate") // run in src dir
	}
	return runFuncInDir("./new-tests", f)
}

func runGoModTidyInTestDirs() error {
	f := func() error {
		// cd into the directory and run go generate followed by go mod tidy
		log.Printf("About to tun: go mod tidy")
		return goCmdV("mod", "tidy") // run in src dir
	}
	return runFuncInDir("./new-tests", f)
}

func runGoBuildInTestDirs() error {
	f := func() error {
		envs := map[string]string{
			"GOOS":   "js",
			"GOARCH": "wasm",
		}

		// the test is defined as a module, so we need to use go list -m to find the module name
		// go list will read and parse the local go.mod for us
		log.Printf("About to tun: go list -m")
		module, err := goCmdCaptureOutput("list", "-m") // -m will print the module path
		if err != nil {
			return err
		}
		log.Printf("About to tun: go build -o ./main.wasm %s", module)
		return goCmdWithV(envs, "build", "-o", "./main.wasm", module)
	}
	return runFuncInDir("./new-tests", f)
}

func runGoTestInTestDirs() error {
	f := func() error {
		// finally run the actual test - this uses the standard Go compiler

		// the test is defined as a module, so we need to use go list -m to find the module name
		// go list will read and parse the local go.mod for us
		log.Printf("About to run: go list -m")
		module, err := goCmdCaptureOutput("list", "-m") // -m will print the module path
		if err != nil {
			return err
		}
		log.Printf("About to tun: go test -v %s", module)
		return goCmdV("test", "-v", module)
	}
	return runFuncInDir("./new-tests", f)
}

func runFuncInDir(dir string, f func() error) error {
	cwd, err := os.Getwd() //  cwd should be the module root
	if err != nil {
		fmt.Println("1")
		return err
	}
	defer func() {
		_ = os.Chdir(cwd)
	}()

	// resolve the dir to an absolute, not symlink path. On MacOS we need to resolve the symlinks....
	dir, err = filepath.Abs(dir)
	if err != nil {
		return err
	}
	dir, err = filepath.EvalSymlinks(dir)
	if err != nil {
		return err
	}
	// Change dir into the new test directory - currently called "new-tests"
	err = os.Chdir(dir)
	if err != nil {
		fmt.Println("2")
		return err
	}

	// find all the directories under "new-tests"
	entries, err := os.ReadDir(dir)
	if err != nil {
		fmt.Println(dir)
		fmt.Println("3")
		c, _ := os.Getwd()
		fmt.Println(c)
		return err
	}
	for _, e := range entries {
		// skip any files
		if !e.IsDir() {
			continue
		}
		cwd, err := os.Getwd()
		if err != nil {
			fmt.Println("4")
			return nil
		}
		err = os.Chdir(e.Name())
		if err != nil {
			_ = os.Chdir(cwd) // can't defer this as defer is function scope when we want look scope
			return nil
		}
		newcwd, _ := os.Getwd()
		log.Printf("Running command in: %s", newcwd)
		err = f()
		if err != nil {
			fmt.Println("5")
			_ = os.Chdir(cwd)
			return err
		}
		_ = os.Chdir(cwd)
	}
	return nil
}

func cleanupContainer(containerName string) error {
	if err := dockerCmdV("stop", containerName); err != nil {
		return err
	}
	// remove the vugu-nginx container - again ignore the error
	return dockerCmdV("rm", containerName)
}

func cleanupContainerNetwork(networkName string) error {
	// remove the vugu-nginx container - again ignore the error
	return dockerCmdV("network", "rm", networkName)
}
